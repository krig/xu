#!/usr/bin/env python
#
# xu


import xmmsclient
import xmmsclient.glib
import sys
import os
import urwid
import urwid.raw_display
import logging as log

from urwid import AttrMap, ListBox, Frame, Text, Padding, WidgetWrap, Columns, SimpleFocusListWalker

PROMPT = u">>"


log.basicConfig(filename='xu.log', level=log.DEBUG)


class XmmsError(Exception):
    def __init__(self, msg):
        Exception.__init__(self, msg)


class Client(object):
    """
    XMMS client wrapper
    """
    def __init__(self):
        self.xmms = None
        self.conn = None

    def connect(self):
        self.xmms = xmmsclient.XMMS("xu0")
        try:
            self.xmms.connect(os.getenv("XMMS_PATH"))
        except IOError, e:
            raise XmmsError(e)
        self.conn = xmmsclient.glib.GLibConnector(self.xmms)

    def _sync(self, r):
        r.wait()
        if r.iserror():
            raise XmmsError(r.get_error())
        return r.value()

    def current(self):
        return self._sync(self.xmms.playback_current_id())

    def medialib_info(self, track):
        return self._sync(self.xmms.medialib_get_info(track))

    def ls(self):
        return self._sync(self.xmms.playlist_list_entries())

    def play(self):
        return self._sync(self.xmms.playback_start())

    def stop(self):
        return self._sync(self.xmms.playback_stop())

    def pause(self):
        return self._sync(self.xmms.playback_pause())

    def tickle(self):
        return self._sync(self.xmms.playback_tickle())

    def set_next(self, index):
        return self._sync(self.xmms.playlist_set_next(index))

    def status(self):
        return self._sync(self.xmms.playback_status())

    def stopped(self):
        return self.status() == 0

    def playing(self):
        return self.status() == 1

    def paused(self):
        return self.status() == 2

    def playing_info(self):
        if self.playing():
            info = self.medialib_info(self.current())
            return u"%s %s - %s" % (PROMPT, info.get('artist', ''), info.get('title', ''))
        else:
            return PROMPT

    def entry_info(self, name, pos):
        lst = self._sync(self.xmms.playlist_list_entries(name))
        return self.medialib_info(lst[pos])

    def playtime(self):
        return self._sync(self.xmms.playback_playtime())

    def jump(self, trackid):
        pl = self.ls()
        for n, tid in enumerate(pl):
            if trackid == tid:
                return self.set_next(n)
        return False

    def set_on_pos_changed(self, cb):
        self.xmms.broadcast_playlist_current_pos(cb)

    def set_on_playlist_changed(self, cb):
        self.xmms.broadcast_playlist_changed(cb)

    def set_on_playback_current_id(self, cb):
        self.xmms.broadcast_playback_current_id(cb)

    def set_on_playback_status(self, cb):
        self.xmms.broadcast_playback_status(cb)


class EntryWidget(WidgetWrap):
    def __init__(self, id, pln, artist, title):
        self.id = id
        self.song_pln = pln
        self.song_artist = artist
        self.song_title = title
        self.content = '%s - %s' % (artist, title)
        self.item = [
            ('fixed', 5, Padding(AttrMap(Text(pln, align='right'), 'body', 'focus'), align='right', right=1)),
            AttrMap(Text(self.content), 'body', 'focus'),
        ]
        w = Columns(self.item)
        super(EntryWidget, self).__init__(w)

    def set_current(self, is_current):
        if is_current:
            self.item[1].set_attr_map({None: 'highlight'})
        else:
            self.item[1].set_attr_map({None: 'body'})

    def selectable(self):
        return True

    def keypress(self, size, key):
        return key


class Xui(object):
    """
    Curses UI to the XMMS client
    """
    def __init__(self, client):
        self.client = client
        self.loop = None
        self.rebuilding = False
        self.progress_enabled = False
        self.current_id = None
        self.current_info = None

    def unhandled(self, key):
        if isinstance(key, tuple):
            if key[0] == 'mouse press':
                pass
            elif key[0] == 'mouse release':
                idx = key[3]
                self.client.set_next(idx - 1)
                if not self.client.playing():
                    self.client.play()
                self.client.tickle()
            return
        key = key.lower()
        if key == 'p':
            if self.client.playing():
                self.client.pause()
            else:
                self.client.play()
        elif key == 's':
            self.client.stop()
        elif key == 'enter':
            focus = self.listbox.get_focus()[0].id
            self.client.jump(focus)
            if not self.client.playing():
                self.client.play()
            self.client.tickle()
        elif key == 'esc' or key == 'q':
            raise urwid.ExitMainLoop()

    def on_pos_changed(self, v):
        #log.debug("pos changed! " + str(v))
        x = v.value()
        pos = x[u'position']
        for idx, w in enumerate(self.listbox.body):
            w.set_current(idx == pos)

    def on_playlist_changed(self, v):
        #log.debug("playlist_changed: " + str(v))

        def rebuilder(loop, data):
            if self.rebuild_list():
                self.loop.draw_screen()
        if not self.rebuilding:
            self.rebuilding = True
            self.loop.set_alarm_in(0.5, rebuilder)

    def on_playback_current_id(self, v):
        if not v:
            self.current_id = None
        else:
            self.current_id = v.value()
        if self.current_id:
            self.current_info = self.client.medialib_info(self.current_id)
            log.debug("current_id: " + str(self.current_id))
            log.debug("current info: " + str(self.current_info))

    def on_playback_status(self, v):
        status = v.value()
        log.debug("playback_status: %s" % (status))
        if status == 0:  # stopped
            self.current_id = None
            self.current_info = None
            self.set_progress(0, 100)

    def rebuild_list(self):
        try:
            while len(self.listbox.body):
                self.listbox.body.pop()
            log.debug("List length is now %d items" % (len(self.listbox.body)))
            curr = self.client.current()
            playlist = self.client.ls()
            for idx, item in enumerate(playlist):
                info = self.client.medialib_info(item)
                artist = info.get('artist', '')
                title = info.get('title', '')
                w = EntryWidget(item, str(idx+1), artist, title)
                if curr == item:
                    w.set_current(True)
                self.listbox.body.append(w)
            log.debug("Rebuilt list! %d items" % (len(self.listbox.body)))
        finally:
            self.rebuilding = False
        return True

    def on_click(self, btn, choice):
        song_id = choice[0]
        self.client.jump(song_id)
        if not self.client.playing():
            self.client.play()
        self.client.tickle()

    def set_progress(self, amt):
        ''' set progress in percentages'''
        self.header.set_completion(amt)

    def refresh_current_id(self):
        if self.current_id:
            return self.current_id
        self.current_id = self.client.current()
        if self.current_id:
            self.current_info = self.client.medialib_info(self.current_id)
            log.debug("current_id: " + str(self.current_id))
            log.debug("current info: " + str(self.current_info))
        return self.current_id

    def start_progress(self):
        def update_progress(loop, obj):
            curr = obj.refresh_current_id()
            if curr:
                playtime = obj.client.playtime()
                duration = obj.current_info.get('duration', 0)
                #log.debug("update progress for %s: %s / %s" % (curr, playtime, duration))
                if duration > 0:
                    obj.set_progress(int(float(playtime) / float(duration) * 100.0))
                else:
                    obj.set_progress(0)
            if obj.progress_enabled:
                loop.set_alarm_in(5, update_progress, obj)
        self.progress_enabled = True
        update_progress(self.loop, self)

    def stop_progress(self):
        self.progress_enabled = False

    def display(self):
        self.palette = [
            ('body', 'dark cyan', ''),
            ('focus', 'white', 'black'),
            ('highlight', 'dark red', ''),
            ('header', 'light gray', '', 'bold'),
            ('progress_off', 'dark gray', '', ''),
            ('progress_on', 'dark gray', 'black', '')
        ]
        self.screen = urwid.raw_display.Screen()
        #self.header = AttrMap(Text(self.client.playing_info()), 'header')
        self.header = urwid.ProgressBar('progress_off', 'progress_on', 50, 100)
        self.listbox = ListBox(SimpleFocusListWalker([]))
        self.rebuild_list()
        self.frame = Frame(AttrMap(self.listbox, 'body'), header=self.header)
        self.client.set_on_pos_changed(self.on_pos_changed)
        self.client.set_on_playlist_changed(self.on_playlist_changed)
        self.client.set_on_playback_current_id(self.on_playback_current_id)
        self.client.set_on_playback_status(self.on_playback_status)
        self.client.xmms.playback_current_id(cb=self.on_playback_current_id)
        log.debug("Starting mainloop...")
        self.loop = urwid.MainLoop(self.frame,
                                   self.palette,
                                   self.screen,
                                   unhandled_input=self.unhandled,
                                   event_loop=urwid.GLibEventLoop())
        self.start_progress()
        self.loop.run()


def main():
    try:
        log.info("--- starting ---")
        client = Client()
        client.connect()

        xui = Xui(client)
        xui.display()
    except XmmsError, e:
        print >> sys.stderr, "Error: %s" % (e)
        sys.exit(1)

if __name__ == "__main__":
    main()
