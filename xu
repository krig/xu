#!/usr/bin/env python
#
# xu


import xmmsclient
import xmmsclient.glib
import xmmsclient.collections as coll
import sys
import os
import urwid
import urwid.raw_display
import logging as log

from urwid import AttrMap, ListBox, Frame, Text, Padding, WidgetWrap, Columns, SimpleFocusListWalker

PROMPT = u">>"


log.basicConfig(filename='xu.log', level=log.DEBUG)


class XmmsError(Exception):
    def __init__(self, msg):
        Exception.__init__(self, msg)


class Client(object):
    """
    XMMS client wrapper
    """
    def __init__(self):
        self.xmms = None
        self.conn = None

    def connect(self):
        self.xmms = xmmsclient.XMMS("xu0")
        try:
            self.xmms.connect(os.getenv("XMMS_PATH"))
        except IOError, e:
            raise XmmsError(e)
        self.conn = xmmsclient.glib.GLibConnector(self.xmms)

    def _sync(self, r):
        r.wait()
        if r.iserror():
            v = r.value()
            if isinstance(v, basestring):
                raise XmmsError(v)
            elif isinstance(v, xmmsclient.XMMSValue):
                raise XmmsError(v.get_error())
            else:
                raise XmmsError(repr(v))
        return r.value()

    def current_id(self):
        return self._sync(self.xmms.playback_current_id())

    def current_pos(self):
        pos = self._sync(self.xmms.playlist_current_pos())
        if pos:
            return pos[u'position']
        return None

    def medialib_info(self, track):
        log.debug("Get info: " + repr(track))
        return self._sync(self.xmms.medialib_get_info(track))

    def ls(self):
        return self._sync(self.xmms.playlist_list_entries())

    def play(self):
        return self._sync(self.xmms.playback_start())

    def stop(self):
        return self._sync(self.xmms.playback_stop())

    def pause(self):
        return self._sync(self.xmms.playback_pause())

    def tickle(self):
        return self._sync(self.xmms.playback_tickle())

    def set_next(self, index):
        return self._sync(self.xmms.playlist_set_next(index))

    def status(self):
        return self._sync(self.xmms.playback_status())

    def stopped(self):
        return self.status() == 0

    def playing(self):
        return self.status() == 1

    def paused(self):
        return self.status() == 2

    def playing_info(self):
        if self.playing():
            info = self.medialib_info(self.current_id())
            return u"%s %s - %s" % (PROMPT, info.get('artist', ''), info.get('title', ''))
        else:
            return PROMPT

    def entry_info(self, name, pos):
        lst = self._sync(self.xmms.playlist_list_entries(name))
        return self.medialib_info(lst[pos])

    def playtime(self):
        return self._sync(self.xmms.playback_playtime())

    def match(self, artist=None, album=None, title=None):
        if artist:
            return coll.Match(field='artist', value=artist)
        elif album:
            return coll.Match(field='album', value=album)
        elif title:
            return coll.Match(field='title', value=title)
        else:
            return None

    def query(self, coll, order):
        '''coll is a collection object
        order is a string describing how to sort the result
        returns all matching ids

        client.query(client.match(album="foo"))
        '''
        return self._sync(self.xmms.coll_query_ids(coll, order.split()))

    def add_collection(self, coll, order):
        '''coll is a collection object
        order is a string describing how to sort the result
        adds the collection object to the playlist
        '''
        return self._sync(self.xmms.playlist_add_collection(coll, order.split()))

    def jump(self, trackid):
        pl = self.ls()
        for n, tid in enumerate(pl):
            if trackid == tid:
                return self.set_next(n)
        return False

    def set_on_pos_changed(self, cb):
        self.xmms.broadcast_playlist_current_pos(cb)

    def set_on_playlist_changed(self, cb):
        self.xmms.broadcast_playlist_changed(cb)

    def set_on_playback_current_id(self, cb):
        self.xmms.broadcast_playback_current_id(cb)

    def set_on_playback_status(self, cb):
        self.xmms.broadcast_playback_status(cb)


class EntryWidget(WidgetWrap):
    def __init__(self, id, pln, artist, title):
        self.id = id
        self.song_pln = pln
        self.song_artist = artist
        self.song_title = title
        self.content = '%s - %s' % (artist, title)
        self.item = [
            ('fixed', 5, Padding(AttrMap(Text(pln, align='right'), 'body', 'focus'), align='right', right=1)),
            AttrMap(Text(self.content), 'body', 'focus'),
        ]
        w = Columns(self.item)
        super(EntryWidget, self).__init__(w)

    def set_current(self, is_current):
        if is_current:
            self.item[1].set_attr_map({None: 'highlight'})
        else:
            self.item[1].set_attr_map({None: 'body'})

    def selectable(self):
        return True

    def keypress(self, size, key):
        return key


class XuiProgressBar(urwid.ProgressBar):
    def __init__(self):
        super(XuiProgressBar, self).__init__('progress_off', 'progress_on', 0, 100)

    def get_text(self):
        return ""


class Xui(object):
    """
    Curses UI to the XMMS client
    """
    def __init__(self, client):
        self.client = client
        self.loop = None
        self.rebuilding = False
        self.progress_enabled = False
        self.current_id = None
        self.current_info = None
        self.current_pos = None

    def unhandled(self, key):
        if isinstance(key, tuple):
            return
        key = key.lower()
        if key == 'p':
            if self.client.playing():
                self.client.pause()
            else:
                self.client.play()
        elif key == 's':
            self.client.stop()
        elif key == 'a':
            self.show_search_ui()
        #elif key == 'y':
        #    yobquery = self.client.match(artist='YOB')
        #    if yobquery:
        #        self.client.add_collection(yobquery, 'artist')
        #    else:
        #        log.debug("yob query failed")
        elif key == 'enter':
            focus = self.listbox.get_focus()[0].id
            self.client.jump(focus)
            if not self.client.playing():
                self.client.play()
            self.client.tickle()
        elif key == 'esc' or key == 'q':
            raise urwid.ExitMainLoop()

    def show_search_ui(self):
        pass

    def on_pos_changed(self, v):
        x = v.value()
        pos = x[u'position']
        self.current_pos = pos
        for idx, w in enumerate(self.listbox.body):
            is_focus = idx == pos
            w.set_current(is_focus)
        self.listbox.set_focus(pos)

    def on_playlist_changed(self, v):
        def rebuilder(loop, data):
            if self.rebuild_list():
                self.loop.draw_screen()
        if not self.rebuilding:
            self.rebuilding = True
            self.loop.set_alarm_in(1.0, rebuilder)

    def on_playback_current_id(self, v):
        if not v:
            self.current_id = None
        else:
            self.current_id = v.value()
        if self.current_id:
            self.current_info = self.client.medialib_info(self.current_id)
            log.debug("current_id: " + str(self.current_id))
            log.debug("current info: " + str(self.current_info))

    def on_playback_status(self, v):
        status = v.value()
        log.debug("playback_status: %s" % (status))
        if status == 0:  # stopped
            self.current_id = None
            self.current_info = None
            self.set_progress(0, 100)

    def rebuild_list(self):
        if self.listbox.focus:
            focus = self.listbox.focus_position
        else:
            focus = None
        retries = 3
        retry = 0
        try:
            while retry < retries:
                try:
                    while len(self.listbox.body):
                        self.listbox.body.pop()
                    playlist = self.client.ls()
                    self.current_id = self.client.current_id()
                    self.current_pos = self.client.current_pos()
                    log.debug("Rebuilding: %s, %s, %s", self.current_id, self.current_pos, playlist)
                    for idx, item in enumerate(playlist):
                        info = self.client.medialib_info(item)
                        artist = info.get('artist', '')
                        title = info.get('title', '')
                        w = EntryWidget(item, str(idx+1), artist, title)
                        if idx == self.current_pos:
                            w.set_current(True)
                        self.listbox.body.append(w)
                    if focus:
                        self.listbox.set_focus(focus)
                    log.debug("Rebuilt list! %d items" % (len(self.listbox.body)))
                    return True
                except XmmsError, e:
                    log.exception(e)
                retry += 1
        finally:
            self.rebuilding = False

    def on_click(self, btn, choice):
        song_id = choice[0]
        self.client.jump(song_id)
        if not self.client.playing():
            self.client.play()
        self.client.tickle()

    def set_progress(self, amt):
        ''' set progress in percentages'''
        self.header.set_completion(amt)

    def refresh_current_id(self):
        if self.current_id:
            return self.current_id
        self.current_id = self.client.current_id()
        if self.current_id:
            self.current_info = self.client.medialib_info(self.current_id)
            log.debug("current_id: " + str(self.current_id))
            log.debug("current info: " + str(self.current_info))
        return self.current_id

    PROGRESS_REFRESH_RATE = 2

    def start_progress(self):
        def update_progress(loop, obj):
            curr = obj.refresh_current_id()
            if curr:
                playtime = obj.client.playtime()
                duration = obj.current_info.get('duration', 0)
                #log.debug("update progress for %s: %s / %s" % (curr, playtime, duration))
                if duration > 0:
                    obj.set_progress(int(float(playtime) / float(duration) * 100.0))
                else:
                    obj.set_progress(0)
            if obj.progress_enabled:
                loop.set_alarm_in(obj.PROGRESS_REFRESH_RATE, update_progress, obj)
        self.progress_enabled = True
        update_progress(self.loop, self)

    def stop_progress(self):
        self.progress_enabled = False

    def display(self):
        self.palette = [
            ('body', 'dark cyan', ''),
            ('focus', 'white', 'black'),
            ('highlight', 'dark red', ''),
            ('header', 'light gray', '', 'bold'),
            ('progress_off', 'dark gray', '', ''),
            ('progress_on', 'dark gray', 'black', ''),
        ]
        self.screen = urwid.raw_display.Screen()
        #self.header = AttrMap(Text(self.client.playing_info()), 'header')
        self.header = XuiProgressBar()
        self.listbox = ListBox(SimpleFocusListWalker([]))
        self.rebuild_list()
        self.frame = Frame(AttrMap(self.listbox, 'body'), header=self.header)
        self.client.set_on_pos_changed(self.on_pos_changed)
        self.client.set_on_playlist_changed(self.on_playlist_changed)
        self.client.set_on_playback_current_id(self.on_playback_current_id)
        self.client.set_on_playback_status(self.on_playback_status)
        self.client.xmms.playback_current_id(cb=self.on_playback_current_id)
        self.client.xmms.playlist_current_pos(cb=self.on_pos_changed)
        log.debug("Starting mainloop...")
        self.loop = urwid.MainLoop(self.frame,
                                   self.palette,
                                   self.screen,
                                   unhandled_input=self.unhandled,
                                   event_loop=urwid.GLibEventLoop(),
                                   handle_mouse=True)
        self.start_progress()
        self.loop.run()


def main():
    try:
        log.info("--- starting ---")
        client = Client()
        client.connect()

        xui = Xui(client)
        xui.display()
    except XmmsError, e:
        print >> sys.stderr, "Error: %s" % (e)
        sys.exit(1)

if __name__ == "__main__":
    main()
