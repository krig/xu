#!/usr/bin/env python
"""
Album art display web service:

Frontend is a javascript program which displays album art,
when the album art is clicked, a page is shown with more information
and options to play or enqueue the given album or individual song.
The backend connects to xmms2 both to find music and to play music.
"""

import os
import json
import xmmsclient as xm
import xmmsclient.collections as xc
from threading import Thread
from flask import Flask, render_template, send_file
app = Flask(__name__)
app.config.from_object(__name__)

BINDATA = os.path.expanduser('~/.config/xmms2/bindata')
FIELDS = ["artist", "compilation", "album", "picture_front", 'picture_front_mime']


class Album(object):
    """
    Represents an album by:
    index
    album
    picture
    mime
    """
    __slots__ = ('idx', 'album', 'picture', 'mime')

    def __init__(self, idx, album, pic, mime):
        self.idx = idx
        self.album = album
        self.picture = pic
        self.mime = mime

    def __str__(self):
        return self.album.encode('utf-8')


class Xmms1(object):
    def __init__(self, xmms2):
        self.xmms = xm.XMMSSync("xub1")
        self.xmms.connect(os.getenv("XMMS_PATH"))
        self.albums = xmms2.albums

    def enqueue_album(self, index):
        print "index:", index
        print "albums:", len(self.albums)
        if int(index) < len(self.albums):
            try:
                album = self.albums[index]
                print "album name:", album.album
                ids = self.xmms.coll_query_ids(
                    xc.Match(xc.Universe(),
                             field="album", value=album.album))
                print "album:", album, ":", ids
                for track in ids:
                    self.xmms.playlist_add_id(track)
            except Exception, e:
                print e

    def play_album(self, index):
        print "index:", index
        print "albums:", len(self.albums)
        if int(index) < len(self.albums):
            try:
                album = self.albums[index]
                print "album name:", album.album
                ids = self.xmms.coll_query_ids(
                    xc.Match(xc.Universe(),
                             field="album", value=album.album))
                print "album:", album, ":", ids
                self.xmms.playlist_clear()
                for track in ids:
                    self.xmms.playlist_add_id(track)
                self.xmms.playback_stop()
                self.xmms.playlist_set_next(0)
                self.xmms.playback_start()
            except Exception, e:
                print e

    def infos_for_album(self, album):
        return self.xmms.coll_query_infos(
            xc.Match(xc.Universe(),
                     field="album",
                     value=album.album),
            ["artist", "collection", "album", "tracknr", "id"])


class Xmms2(Thread):
    def __init__(self):
        Thread.__init__(self, name="Xmms2")
        self.xmms = xm.XMMS("xub0")
        self.albums = []

    def on_albumlist(self, albums_data):
        if albums_data.is_error():
            print albums_data.get_error()
            return
        albums = sorted(albums_data.value(), key=lambda a: a.get('artist') or a.get('compilation'))
        for album in albums:
            album_obj = Album(len(self.albums),
                              album['album'],
                              album['picture_front'],
                              album['picture_front_mime'])
            self.albums.append(album_obj)

    def on_albumlist_changed(self, albums_data):
        if albums_data.is_error():
            print albums_data.get_error()
            return
        for album in albums_data.value():
            for album2 in self.albums:
                if album2.album == album['album']:
                    album2.picture = album['picture_front']
                    album2.mime = album['picture_front_mime']
            else:
                album_obj = Album(len(self.albums),
                                  album['album'],
                                  album['picture_front'],
                                  album['picture_front_mime'])
                self.albums.append(album_obj)

    def on_added(self, album_data):
        if album_data.is_error():
            print album_data.get_error()
            return
        trackid = album_data.value()
        print "added", trackid
        self.xmms.coll_query_infos(xc.Match(xc.Universe(), field="id", value=unicode(trackid)),
                                   fields=FIELDS,
                                   groupby=["album"],
                                   cb=self.on_albumlist_changed)

    def on_changed(self, album_data):
        if album_data.is_error():
            print album_data.get_error()
            return
        trackid = album_data.value()
        print "changed", trackid
        self.xmms.coll_query_infos(xc.Match(xc.Universe(), field="id", value=unicode(trackid)),
                                   fields=FIELDS,
                                   groupby=["album"],
                                   cb=self.on_albumlist_changed)

    def run(self):
        self.xmms.connect(os.getenv("XMMS_PATH"))
        self.xmms.broadcast_medialib_entry_added(cb=self.on_added)
        self.xmms.broadcast_medialib_entry_changed(cb=self.on_changed)
        self.xmms.coll_query_infos(xc.Universe(),
                                   fields=FIELDS,
                                   groupby=["album"],
                                   cb=self.on_albumlist)
        self.xmms.loop()


xmms2 = Xmms2()
xmms2.start()
xmms1 = Xmms1(xmms2)


@app.route("/")
def albums():
    return render_template("index.html",
                           title="xub :: albums",
                           albums=xmms2.albums)


@app.route("/playlist")
def playlist_page():
    return render_template("playlist.html",
                           title="xub :: playlist")


@app.route("/api/enqueue/<int:albumidx>")
def enqueue(albumidx):
    xmms1.enqueue_album(albumidx)
    return ""


@app.route("/api/play/<int:albumidx>")
def play(albumidx):
    xmms1.play_album(albumidx)
    return ""


@app.route("/fonts/<font>")
def fonts(font):
    "route as staticish"
    if '/' in font or '..' in font:
        return ""
    return send_file(os.path.join("fonts", font), mimetype='application/binary')


def clean(mediainfo):
    return dict((key[1], value) for key, value in mediainfo.iteritems())


@app.route("/api/current")
def nowplaying():
    try:
        now = xmms1.xmms.playback_current_id()
        info = xmms1.xmms.medialib_get_info(now)
        status = xmms1.xmms.playback_status()
        ret = clean(info)
        ret[u'status'] = status
        return json.dumps(ret)
    except Exception, e:
        print e
        return json.dumps({"error": str(e)})

@app.route("/api/playback/<status>")
def api_playback(status):
    if status == "toggle":
        xmms1.xmms.playback_toggle()
    elif status == "stop":
        xmms1.xmms.playback_stop()
    return ""


@app.route("/api/playlist")
def playlist():
    try:
        pos = xmms1.xmms.playlist_current_pos()
        entries = xmms1.xmms.playlist_list_entries()
        pos['playlist'] = [clean(xmms1.xmms.medialib_get_info(entry)) for entry in entries]
        return json.dumps(pos)
    except Exception, e:
        print e
        return json.dumps({"error": str(e)})


@app.route("/api/album/<int:index>")
def album(index):
    try:
        if index < len(xmms2.albums):
            album = xmms2.albums[index]
            infos = xmms1.infos_for_album(album)

            return json.dumps({'album': album.album,
                               'index': album.idx,
                               'tracks': infos})
    except Exception, e:
        print e
    return json.dumps({'error': "Haven't loaded %s yet" % (index)})


@app.route("/api/art/<int:index>")
def albumart(index):
    try:
        index = int(index)
        if index >= len(xmms2.albums):
            raise ValueError("index out of range: %s" % (index))
        album = xmms2.albums[index]
        if not album.picture:
            raise ValueError("album has no art: %s %s" % (index, album.album.encode('utf-8')))
        data = os.path.join(BINDATA, album.picture)
        mime = album.mime
        print data, mime
        return send_file(data, mimetype=mime)
    except Exception, e:
        print e
        data = 'static/none.jpg'
        mime = 'image/jpeg'
        return send_file(data, mimetype=mime)

if __name__ == "__main__":
    app.run()
    xmms2.xmms.exit_loop()
